package com.example.edai.ui.viewmodel

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.example.edai.data.model.*
import com.example.edai.data.repository.PopularPlacesRepository
import com.example.edai.data.repository.GeminiRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class PopularPlacesUiState(
    val isLoading: Boolean = false,
    val places: List<PopularPlace> = emptyList(),
    val filteredPlaces: List<PopularPlace> = emptyList(),
    val categories: List<String> = emptyList(),
    val selectedCategory: String = "All",
    val error: String? = null
)

data class PlaceDetailUiState(
    val isLoading: Boolean = false,
    val place: PopularPlace? = null,
    val error: String? = null
)

data class QuizUiState(
    val isLoading: Boolean = false,
    val questions: List<PlaceQuizQuestion> = emptyList(),
    val currentQuestionIndex: Int = 0,
    val selectedAnswers: MutableList<Int> = mutableListOf(), // Changed back to MutableList for better state management
    val showResults: Boolean = false,
    val score: Int = 0,
    val error: String? = null,
    val currentPlaceId: Int = -1, // Added to track which place the quiz belongs to
    val isGeminiGenerated: Boolean = false // Track if quiz is generated by Gemini
)

data class GeminiPlaceUiState(
    val isLoading: Boolean = false,
    val enhancedInfo: GeminiPlaceInfo? = null,
    val geminiQuizQuestions: List<GeminiQuizQuestion> = emptyList(),
    val error: String? = null,
    val isGeminiAvailable: Boolean = true
)

class PopularPlacesViewModel(application: Application) : AndroidViewModel(application) {
    
    private val repository = PopularPlacesRepository(application)
    private val geminiRepository = GeminiRepository(application)
    
    private val _uiState = MutableStateFlow(PopularPlacesUiState())
    val uiState: StateFlow<PopularPlacesUiState> = _uiState.asStateFlow()
    
    private val _placeDetailState = MutableStateFlow(PlaceDetailUiState())
    val placeDetailState: StateFlow<PlaceDetailUiState> = _placeDetailState.asStateFlow()
    
    private val _quizState = MutableStateFlow(QuizUiState())
    val quizState: StateFlow<QuizUiState> = _quizState.asStateFlow()
    
    private val _geminiState = MutableStateFlow(GeminiPlaceUiState())
    val geminiState: StateFlow<GeminiPlaceUiState> = _geminiState.asStateFlow()
    
    init {
        loadPopularPlaces()
    }
    
    fun loadPopularPlaces() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            repository.getPopularPlaces().fold(
                onSuccess = { places ->
                    val categories = listOf("All") + places.map { it.category }.distinct().sorted()
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        places = places,
                        filteredPlaces = places,
                        categories = categories,
                        error = null
                    )
                },
                onFailure = { exception ->
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = exception.message ?: "Unknown error occurred"
                    )
                }
            )
        }
    }
    
    fun filterByCategory(category: String) {
        val currentState = _uiState.value
        val filteredPlaces = if (category == "All") {
            currentState.places
        } else {
            currentState.places.filter { it.category == category }
        }
        
        _uiState.value = currentState.copy(
            selectedCategory = category,
            filteredPlaces = filteredPlaces
        )
    }
    
    fun loadPlaceDetail(placeId: Int) {
        viewModelScope.launch {
            _placeDetailState.value = _placeDetailState.value.copy(isLoading = true, error = null)
            
            repository.getPlaceById(placeId).fold(
                onSuccess = { place ->
                    _placeDetailState.value = _placeDetailState.value.copy(
                        isLoading = false,
                        place = place,
                        error = if (place == null) "Place not found" else null
                    )
                },
                onFailure = { exception ->
                    _placeDetailState.value = _placeDetailState.value.copy(
                        isLoading = false,
                        error = exception.message ?: "Failed to load place details"
                    )
                }
            )
        }
    }
    
    fun startQuiz(place: PopularPlace) {
        Log.d("QuizViewModel", "Starting quiz for place: ${place.name} (ID: ${place.id})")
        
        // Reset quiz state completely before starting new quiz
        val initialAnswers = MutableList(place.quiz.size) { -1 } // -1 means no answer selected
        
        _quizState.value = QuizUiState(
            questions = place.quiz,
            currentQuestionIndex = 0,
            selectedAnswers = initialAnswers,
            showResults = false,
            score = 0,
            currentPlaceId = place.id,
            error = null
        )
        
        Log.d("QuizViewModel", "Quiz initialized with ${place.quiz.size} questions")
    }
    
    fun selectAnswer(questionIndex: Int, answerIndex: Int) {
        val currentState = _quizState.value
        
        Log.d("QuizViewModel", "Selecting answer: Q$questionIndex = Option $answerIndex")
        
        // Ensure we're not out of bounds
        if (questionIndex >= 0 && questionIndex < currentState.selectedAnswers.size) {
            // Create a new mutable list from current state
            val updatedAnswers = currentState.selectedAnswers.toMutableList()
            updatedAnswers[questionIndex] = answerIndex
            
            _quizState.value = currentState.copy(
                selectedAnswers = updatedAnswers
            )
            
            Log.d("QuizViewModel", "Answer selected. Current answers: ${updatedAnswers}")
        } else {
            Log.e("QuizViewModel", "Invalid question index: $questionIndex")
        }
    }
    
    fun nextQuestion() {
        val currentState = _quizState.value
        Log.d("QuizViewModel", "Next question requested. Current: ${currentState.currentQuestionIndex}")
        
        if (currentState.currentQuestionIndex < currentState.questions.size - 1) {
            _quizState.value = currentState.copy(
                currentQuestionIndex = currentState.currentQuestionIndex + 1
            )
            Log.d("QuizViewModel", "Moved to question ${currentState.currentQuestionIndex + 1}")
        } else {
            Log.d("QuizViewModel", "Last question reached, finishing quiz")
            finishQuiz()
        }
    }
    
    fun previousQuestion() {
        val currentState = _quizState.value
        Log.d("QuizViewModel", "Previous question requested. Current: ${currentState.currentQuestionIndex}")
        
        if (currentState.currentQuestionIndex > 0) {
            _quizState.value = currentState.copy(
                currentQuestionIndex = currentState.currentQuestionIndex - 1
            )
            Log.d("QuizViewModel", "Moved to question ${currentState.currentQuestionIndex - 1}")
        }
    }
    
    fun finishQuiz() {
        val currentState = _quizState.value
        Log.d("QuizViewModel", "Finishing quiz...")
        
        val score = currentState.questions.indices.count { index ->
            val userAnswer = currentState.selectedAnswers.getOrNull(index) ?: -1
            val correctAnswer = currentState.questions[index].correctAnswer
            userAnswer == correctAnswer
        }
        
        Log.d("QuizViewModel", "Quiz finished. Score: $score/${currentState.questions.size}")
        
        _quizState.value = currentState.copy(
            showResults = true,
            score = score
        )
    }
    
    fun resetQuiz() {
        Log.d("QuizViewModel", "Resetting quiz state")
        _quizState.value = QuizUiState()
    }
    
    // Helper function to check if current question has been answered
    fun isCurrentQuestionAnswered(): Boolean {
        val currentState = _quizState.value
        val currentIndex = currentState.currentQuestionIndex
        return currentIndex >= 0 && 
               currentIndex < currentState.selectedAnswers.size && 
               currentState.selectedAnswers[currentIndex] != -1
    }
    
    // Helper function to get current question's selected answer
    fun getCurrentQuestionAnswer(): Int {
        val currentState = _quizState.value
        val currentIndex = currentState.currentQuestionIndex
        return if (currentIndex >= 0 && currentIndex < currentState.selectedAnswers.size) {
            currentState.selectedAnswers[currentIndex]
        } else -1
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
    
    fun clearPlaceDetailError() {
        _placeDetailState.value = _placeDetailState.value.copy(error = null)
    }
}